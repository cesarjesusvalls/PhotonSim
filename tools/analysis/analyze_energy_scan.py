#!/usr/bin/env python3
"""
Analyze the energy scan results from PhotonSim.

This script reads the ROOT files generated by the energy scan and analyzes
the photon time vs distance histograms for different muon energies.
"""

import ROOT
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
import sys
import argparse

def analyze_energy_scan(scan_directory):
    """Analyze the energy scan results."""
    
    scan_dir = Path(scan_directory)
    if not scan_dir.exists():
        print(f"Error: Directory {scan_dir} not found!")
        return
    
    # Find all ROOT files matching the pattern
    root_files = list(scan_dir.glob("muons_*MeV_scan.root"))
    
    if not root_files:
        print(f"Error: No scan ROOT files found in {scan_dir}")
        return
    
    # Sort files by energy
    def extract_energy(filename):
        # Extract energy from filename like "muons_100MeV_scan.root"
        try:
            energy_str = filename.stem.split('_')[1].replace('MeV', '')
            return int(energy_str)
        except:
            return 0
    
    root_files.sort(key=extract_energy)
    
    print(f"=== Energy Scan Analysis ===")
    print(f"Found {len(root_files)} energy scan files")
    print(f"Energy range: {extract_energy(root_files[0])} - {extract_energy(root_files[-1])} MeV")
    
    # Create figure with four subplots
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(12, 8))
    
    energies = []
    ranges = []  # Store calculated ranges for each energy
    all_timing_data = []  # Store timing data for remaining range analysis
    
    # Colors for different energies
    colors = plt.cm.viridis(np.linspace(0, 1, len(root_files)))
    
    # Process each energy
    for i, root_file in enumerate(root_files):
        energy = extract_energy(root_file)
        energies.append(energy)
        
        print(f"\\nProcessing {energy} MeV...")
        
        # Open ROOT file
        f = ROOT.TFile.Open(str(root_file), "READ")
        if not f or f.IsZombie():
            print(f"  Error: Cannot open {root_file}")
            continue
        
        # Get the photon time vs distance histogram
        hist = f.Get("PhotonHist_TimeDistance")
        if not hist:
            print(f"  Error: PhotonHist_TimeDistance not found in {root_file}")
            f.Close()
            continue
        
        # Calculate mean time vs distance (profile)
        n_bins_x = hist.GetNbinsX()
        n_bins_y = hist.GetNbinsY()
        
        # Calculate statistics
        n_entries = hist.GetEntries()
        print(f"  Photons: {n_entries:,}")
        
        # Create profiles: mean time vs distance AND photon count vs distance
        distances_time = []
        mean_times = []
        distances_count = []
        photon_counts = []
        
        for bin_x in range(1, n_bins_x + 1):
            distance = hist.GetXaxis().GetBinCenter(bin_x)
            
            # Calculate mean time for this distance bin
            total_time_weighted = 0
            total_weight = 0
            
            for bin_y in range(1, n_bins_y + 1):
                content = hist.GetBinContent(bin_x, bin_y)
                if content > 0:
                    time = hist.GetYaxis().GetBinCenter(bin_y)
                    total_time_weighted += content * time
                    total_weight += content
            
            # Store time data
            if total_weight > 0:
                mean_time = total_time_weighted / total_weight
                distances_time.append(distance)
                mean_times.append(mean_time)
            
            # Store count data (total photons in this distance bin)
            if total_weight > 0:
                distances_count.append(distance)
                photon_counts.append(total_weight)
        
        # Plot 1: mean time vs distance for this energy
        if len(distances_time) > 0:
            ax1.plot(distances_time, mean_times, color=colors[i], alpha=0.8, 
                    label=f'{energy} MeV', linewidth=2, marker='o', markersize=2)
            
            # Store timing data for remaining range analysis
            all_timing_data.append({
                'energy': energy,
                'distances': distances_time,
                'times': mean_times,
                'color': colors[i]
            })
        
        # Calculate average photon count per event for this energy
        if len(distances_count) > 0:
            # Get number of events for this energy (assuming 10 events as specified in macro generation)
            n_events = 10  # From the macro generation script
            avg_photon_counts = [count / n_events for count in photon_counts]
            
            # Plot 2: average photon count vs distance
            ax2.plot(distances_count, avg_photon_counts, color=colors[i], alpha=0.8, 
                    label=f'{energy} MeV', linewidth=2, marker='o', markersize=2)
            
            # Calculate range using filtered data (100-5000 average photons per event)
            if len(distances_count) > 2:
                # Filter data: use only points with 100-5000 average photons per event
                filtered_data = [(d, c) for d, c in zip(distances_count, avg_photon_counts) 
                               if 100 <= c <= 5000]
                
                if len(filtered_data) >= 3:  # Need at least 3 points for fitting
                    filtered_distances, filtered_counts = zip(*filtered_data)
                    filtered_distances = np.array(filtered_distances)
                    filtered_counts = np.array(filtered_counts)
                    
                    # Sort by distance to ensure proper ordering
                    sort_idx = np.argsort(filtered_distances)
                    filtered_distances = filtered_distances[sort_idx]
                    filtered_counts = filtered_counts[sort_idx]
                    
                    try:
                        # Linear fit: avg_count = a * distance + b
                        coeffs = np.polyfit(filtered_distances, filtered_counts, 1)
                        a, b = coeffs
                        
                        # Calculate range (distance where avg_count = 0)
                        if a < 0:  # Slope should be negative
                            calculated_range = -b / a
                            ranges.append(calculated_range)
                            
                            # Plot the fit line
                            fit_line_x = np.linspace(filtered_distances[0], calculated_range, 100)
                            fit_line_y = a * fit_line_x + b
                            # Only plot positive part
                            positive_mask = fit_line_y >= 0
                            ax2.plot(fit_line_x[positive_mask], fit_line_y[positive_mask], 
                                    '--', color=colors[i], alpha=0.5, linewidth=1)
                            
                            # Mark the calculated range
                            ax2.axvline(x=calculated_range, color=colors[i], 
                                       linestyle=':', alpha=0.7, linewidth=1)
                            
                            # Highlight the data points used for fitting
                            ax2.scatter(filtered_distances, filtered_counts, 
                                      color=colors[i], alpha=0.3, s=20, marker='s')
                            
                            print(f"  Calculated range: {calculated_range:.1f} mm (using {len(filtered_data)} points)")
                        else:
                            ranges.append(np.nan)
                            print(f"  Could not calculate range (positive slope)")
                    except:
                        ranges.append(np.nan)
                        print(f"  Could not calculate range (fit failed)")
                else:
                    ranges.append(np.nan)
                    print(f"  Could not calculate range (only {len(filtered_data)} points in 100-5000 range)")
            else:
                ranges.append(np.nan)
                print(f"  Could not calculate range (too few data points)")
        
        f.Close()
    
    # Format the plots
    # Plot 1: Time vs Distance
    ax1.set_xlabel('Distance from Origin (mm)', fontsize=12)
    ax1.set_ylabel('Average Photon Creation Time (ns)', fontsize=12)
    ax1.set_title('Average Photon Creation Time vs Distance', fontsize=14)
    ax1.legend(fontsize=9)
    ax1.grid(True, alpha=0.3)
    ax1.set_xlim(0, None)
    ax1.set_ylim(0, None)
    
    # Plot 2: Average Photon Count vs Distance (for range calculation)
    ax2.set_xlabel('Distance from Origin (mm)', fontsize=12)
    ax2.set_ylabel('Average Photons per Event', fontsize=12)
    ax2.set_title('Average Photon Count vs Distance and Calculated Ranges', fontsize=14)
    ax2.legend(fontsize=9)
    ax2.grid(True, alpha=0.3)
    ax2.set_xlim(0, None)
    ax2.set_ylim(0, None)
    
    # Plot 3: Range vs Energy
    ax3.set_xlabel('Energy (MeV)', fontsize=12)
    ax3.set_ylabel('Range (cm)', fontsize=12)
    ax3.set_title('Muon Range vs Energy', fontsize=14)
    ax3.legend(fontsize=10)
    ax3.grid(True, alpha=0.3)
    
    # Plot 4: Timing vs Negative Remaining Range
    ax4.set_xlabel('Negative Remaining Range (cm)', fontsize=12)
    ax4.set_ylabel('Average Photon Creation Time (ns)', fontsize=12)
    ax4.set_title('Photon Timing vs Negative Remaining Range', fontsize=14)
    ax4.legend(fontsize=9)
    ax4.grid(True, alpha=0.3)
    
    plt.tight_layout()
    
    # Save plots
    output_plot = scan_dir / "energy_scan_analysis.png"
    plt.savefig(output_plot, dpi=150, bbox_inches='tight')
    print(f"\\nPlot saved to: {output_plot}")
    
    # Save summary data with ranges
    summary_file = scan_dir / "energy_scan_summary.txt"
    with open(summary_file, 'w') as f:
        f.write("Energy Scan Summary\\n")
        f.write("==================\\n\\n")
        f.write("Energy (MeV)  Calculated Range (mm)\\n")
        f.write("-" * 35 + "\\n")
        for i, energy in enumerate(energies):
            if i < len(ranges):
                range_str = f"{ranges[i]:.1f}" if not np.isnan(ranges[i]) else "N/A"
            else:
                range_str = "N/A"
            f.write(f"{energy:8d}  {range_str:>15s}\\n")
        f.write("\\nTop-left plot: Average photon creation time vs distance\\n")
        f.write("Top-right plot: Average photon count per event vs distance with range calculations\\n")
        f.write("Bottom-left plot: Muon range vs energy with linear fit\\n")
        f.write("Bottom-right plot: Photon timing vs negative remaining range\\n")
        f.write("\\nRange calculation method:\\n")
        f.write("- Use only data points with 100-5000 average photons per event\\n")
        f.write("- Fit linear line to filtered data: avg_count = a*distance + b\\n")
        f.write("- Find intercept where avg_count = 0: range = -b/a\\n")
        f.write("- Dashed lines show fits, dotted lines show calculated ranges\\n")
        f.write("- Square markers highlight data points used in fit\\n")
    
    print(f"Summary saved to: {summary_file}")
    
    # Create range analysis and remaining range plot
    valid_ranges = [(e, r) for e, r in zip(energies, ranges) if not np.isnan(r)]
    if len(valid_ranges) > 2:
        valid_energies, valid_range_values = zip(*valid_ranges)
        
        print(f"\\n=== Range Analysis ===")
        print("Calculated ranges:")
        for energy, range_val in valid_ranges:
            print(f"  {energy:4d} MeV: {range_val:6.1f} mm")
        
        # Plot 3: Range vs Energy (convert mm to cm for better readability)
        valid_range_values_cm = [r/10.0 for r in valid_range_values]  # Convert mm to cm
        print(valid_range_values_cm)
        ax3.scatter(valid_energies, valid_range_values_cm, color='red', s=50, alpha=0.7, zorder=3)
        
        # Linear fit only (as requested)
        try:
            # Linear fit (convert to cm for fitting and display)
            linear_coeffs = np.polyfit(valid_energies, valid_range_values_cm, 1)
            a_lin, b_lin = linear_coeffs
            
            # Calculate R-squared for linear fit
            linear_pred = a_lin * np.array(valid_energies) + b_lin
            ss_res_lin = np.sum((valid_range_values_cm - linear_pred) ** 2)
            ss_tot = np.sum((valid_range_values_cm - np.mean(valid_range_values_cm)) ** 2)
            r2_linear = 1 - (ss_res_lin / ss_tot)
            
            # Plot linear fit
            energy_fit = np.linspace(min(valid_energies), max(valid_energies), 100)
            linear_fit = a_lin * energy_fit + b_lin
            ax3.plot(energy_fit, linear_fit, '--', color='blue', linewidth=2, 
                    label=f'R = {a_lin:.3f}E + {b_lin:.1f} (R² = {r2_linear:.3f})', alpha=0.8)
            
            print(f"\\nLinear fit: R = {a_lin:.3f}*E + {b_lin:.1f} cm (R² = {r2_linear:.3f})")
            
            # Plot 4: Timing vs Negative Remaining Range
            print(f"\\n=== Remaining Range Analysis ===")
            
            # For each energy, calculate remaining range and plot timing
            for timing_data in all_timing_data:
                energy = timing_data['energy']
                distances = np.array(timing_data['distances'])
                times = np.array(timing_data['times'])
                color = timing_data['color']
                
                # Calculate expected total range for this energy using linear fit (in cm)
                expected_range_cm = a_lin * energy + b_lin
                
                # Convert distances from mm to cm for consistency
                distances_cm = distances / 10.0
                
                # Calculate remaining range (negative so it reads left to right)
                remaining_range = -(expected_range_cm - distances_cm)
                
                # Plot timing vs negative remaining range
                # This will show timing as function of how close to the end of the track
                ax4.plot(remaining_range, times, color=color, alpha=0.6, 
                        linewidth=1, marker='o', markersize=2, label=f'{energy} MeV')
            
        except Exception as e:
            print(f"  Could not fit range vs energy relationship: {e}")
    else:
        print(f"\\nNot enough valid ranges ({len(valid_ranges)}) to create range analysis")
    
    # Physics insights
    print(f"\\n=== Physics Insights ===")
    print("Top-left plot: Timing shows how photon creation time varies with distance.")
    print("Top-right plot: Range analysis shows where muon stops producing photons.")
    if len(valid_ranges) > 2:
        print("Bottom-left plot: Shows how muon range scales with energy.")
        print("Bottom-right plot: Shows timing dependence on remaining track length.")
    print("Expected behavior:")
    print("- Timing: Linear t ≈ distance / (c/n) where c/n is speed of light in medium")
    print("- Range: Should increase with energy, approximately R ∝ E^1.8 for muons")
    print("- Remaining range: Timing may vary with distance from track end")
    print("- Cerenkov threshold effects may be visible at lower energies")
    
    plt.show()

def main():
    """Main function."""
    
    parser = argparse.ArgumentParser(description='Analyze energy scan results')
    parser.add_argument('scan_directory', nargs='?', default='energy_scan_macros',
                        help='Directory containing scan ROOT files')
    
    args = parser.parse_args()
    
    analyze_energy_scan(args.scan_directory)

if __name__ == "__main__":
    main()